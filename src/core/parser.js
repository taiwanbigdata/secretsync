const fs = require('fs');
const path = require('path');
const Colors = require('../utils/colors');

class EnvParser {
  /**
   * Parse .env file and return key-value object
   * @param {string} filePath - Path to .env file
   * @returns {Object} Parsed environment variables
   */
  static parseFile(filePath) {
    if (!fs.existsSync(filePath)) {
      console.log(Colors.error(`File not found: ${filePath}`));
      return {};
    }

    try {
      const content = fs.readFileSync(filePath, 'utf-8');
      return this.parseContent(content);
    } catch (error) {
      console.error(Colors.error(`Error reading file ${filePath}: ${error.message}`));
      return {};
    }
  }

  /**
   * Parse .env content string and return key-value object
   * @param {string} content - .env file content
   * @returns {Object} Parsed environment variables
   */
  static parseContent(content) {
    const envVars = {};

    content.split('\n').forEach((line, lineNumber) => {
      line = line.trim();
      
      // Skip empty lines and comments
      if (!line || line.startsWith('#')) {
        return;
      }

      const equalIndex = line.indexOf('=');
      if (equalIndex === -1) {
        console.warn(Colors.warning(`Line ${lineNumber + 1}: Invalid format, skipping: ${line}`));
        return;
      }

      const key = line.slice(0, equalIndex).trim();
      let value = line.slice(equalIndex + 1).trim();

      // Remove surrounding quotes if present
      if ((value.startsWith('"') && value.endsWith('"')) || 
          (value.startsWith("'") && value.endsWith("'"))) {
        value = value.slice(1, -1);
      }

      if (key) {
        envVars[key] = value;
      }
    });

    return envVars;
  }

  /**
   * Write environment variables to .env file
   * @param {string} filePath - Path to write .env file
   * @param {Object} envVars - Environment variables object
   * @param {Object} options - Write options
   */
  static writeFile(filePath, envVars, options = {}) {
    const { 
      addHeader = true, 
      sortKeys = true,
      quoteValues = false 
    } = options;

    let content = '';

    if (addHeader) {
      content += `# Generated by SecretSync\n# ${new Date().toISOString()}\n\n`;
    }

    const keys = sortKeys ? Object.keys(envVars).sort() : Object.keys(envVars);

    keys.forEach(key => {
      const value = envVars[key];
      const quotedValue = quoteValues || value.includes(' ') || value.includes('\n') 
        ? `"${value.replace(/"/g, '\\"')}"` 
        : value;
      
      content += `${key}=${quotedValue}\n`;
    });

    try {
      // Ensure directory exists
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      fs.writeFileSync(filePath, content, 'utf-8');
      console.log(Colors.checkmark(`Wrote ${keys.length} variables to ${filePath}`));
    } catch (error) {
      console.error(Colors.error(`Error writing file ${filePath}: ${error.message}`));
      throw error;
    }
  }

  /**
   * Get common .env file paths for different environments
   * @param {string} environment - Environment name
   * @returns {string} Default file path
   */
  static getDefaultFilePath(environment) {
    const mapping = {
      development: '.env.local',
      preview: '.env.staging',
      production: '.env.production',
      local: '.env.local',
      staging: '.env.staging',
      prod: '.env.production'
    };

    return mapping[environment] || '.env';
  }

  /**
   * Validate environment variables
   * @param {Object} envVars - Environment variables to validate
   * @returns {Object} Validation result
   */
  static validate(envVars) {
    const issues = [];
    const warnings = [];

    Object.entries(envVars).forEach(([key, value]) => {
      // Check for common issues
      if (key.includes(' ')) {
        issues.push(`Key "${key}" contains spaces`);
      }

      if (key.toLowerCase() !== key && key.toUpperCase() !== key) {
        warnings.push(`Key "${key}" uses mixed case (consider using UPPER_CASE)`);
      }

      if (value === '') {
        warnings.push(`Key "${key}" has empty value`);
      }

      if (value.includes('\n')) {
        warnings.push(`Key "${key}" contains newline characters`);
      }
    });

    return {
      isValid: issues.length === 0,
      issues,
      warnings,
      count: Object.keys(envVars).length
    };
  }
}

module.exports = EnvParser;